<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Web AR Navigation (GPS + 2D Map)</title>
  
  <!-- A-Frame + AR.js (location-based) -->
  <script src="https://aframe.io/releases/1.4.1/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/3.4.5/aframe/build/aframe-ar.js"></script>

  <!-- Leaflet (2D map fallback/companion) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

  <style>
    :root{ --bg:#0f1220; --card:#161a2b; --text:#e7ecff; --muted:#a8b0d3; --accent:#70a0ff; --ok:#00d18f; --warn:#ffd166; --danger:#ff6b6b; }
    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; background:var(--bg); color:var(--text); }
    header{ position:fixed; top:0; left:0; right:0; z-index:9999; backdrop-filter:saturate(120%) blur(8px); background:linear-gradient(180deg, rgba(15,18,32,.9), rgba(15,18,32,.6)); border-bottom:1px solid rgba(255,255,255,.08); }
    .bar{ display:flex; gap:.75rem; align-items:center; padding:.75rem 1rem; max-width:1100px; margin:0 auto; }
    h1{ font-size:1rem; margin:0; letter-spacing:.5px; opacity:.95; }
    form{ display:flex; flex-wrap:wrap; gap:.5rem; align-items:center; flex:1; }
    input, button, select{ border:1px solid rgba(255,255,255,.12); background:var(--card); color:var(--text); padding:.6rem .8rem; border-radius:.8rem; outline:none; }
    input::placeholder{ color:var(--muted); }
    button{ cursor:pointer; border:1px solid rgba(255,255,255,.16); }
    .primary{ background:var(--accent); color:#0b1020; border-color:transparent; font-weight:600; }
    .ghost{ background:transparent; }
    .wrap{ display:grid; grid-template-rows:auto 1fr; height:100%; }
    main{ display:grid; grid-template-columns: 1fr; grid-auto-rows:1fr; gap:0; margin-top:64px; }

    /* Panels */
    #mapPanel{ height:calc(100vh - 64px); display:none; }
    #map{ height:100%; width:100%; }
    #arPanel{ height:calc(100vh - 64px); position:relative; display:block; }
    .hud{ position:fixed; left:0; right:0; bottom:0; z-index:9999; padding: .75rem; }
    .hud-inner{ max-width:1100px; margin:0 auto; background:rgba(22,26,43,.85); border:1px solid rgba(255,255,255,.08); border-radius:1rem; padding:.75rem; display:grid; grid-template-columns: 1fr auto; gap:.75rem; align-items:center; }
    .stats{ display:flex; gap:1rem; font-size:.9rem; color:var(--muted); flex-wrap:wrap; }
    .pill{ background:rgba(255,255,255,.06); padding:.4rem .6rem; border-radius:.7rem; }
    .status-ok{ color:var(--ok); }
    .status-warn{ color:var(--warn); }
    .status-bad{ color:var(--danger); }

    .toast{ position:fixed; top:72px; left:50%; transform:translateX(-50%); background:#1f2642; border:1px solid rgba(255,255,255,.12); color:var(--text); padding:.6rem .9rem; border-radius:.7rem; z-index:99999; display:none; }
    .tip{ color:var(--muted); font-size:.85rem; }
    .hidden{ display:none !important; }
    a{ color:var(--accent); text-decoration:none; }

    /* Small screens */
    @media (max-width:720px){
      .bar { padding:.5rem .75rem; }
      .hud-inner{ grid-template-columns:1fr; }
    }

    /* Subtle loading shimmer */
    .shimmer{ background: linear-gradient(90deg, rgba(255,255,255,0.02) 0%, rgba(255,255,255,0.10) 50%, rgba(255,255,255,0.02) 100%); background-size:200% 100%; animation: sh 1.6s infinite; }
    @keyframes sh{ 0%{ background-position:200% 0;} 100%{ background-position: -200% 0;}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="bar">
        <h1>AR Navigation</h1>
        <form id="routeForm">
          <input id="src" type="text" placeholder="Source (leave empty for GPS)" autocomplete="off" />
          <input id="dst" type="text" placeholder="Destination (address or lat,lon)" required />
          <select id="profile" title="Travel mode">
            <option value="foot">Walk</option>
            <option value="driving">Drive (beta)</option>
            <option value="bike">Bike (beta)</option>
          </select>
          <button class="primary" type="submit">Go</button>
          <button id="toggleView" type="button" class="ghost">Show Map</button>
        </form>
      </div>
    </header>

    <main>
      <!-- AR Panel -->
      <section id="arPanel">
        <!-- A-Frame scene: location-based AR via AR.js -->
        <a-scene vr-mode-ui="enabled: false" renderer="logarithmicDepthBuffer: true; antialias:true" embedded arjs="sourceType: webcam; videoTexture: true; debugUIEnabled: false;">
          <a-camera gps-camera rotation-reader></a-camera>

          <!-- Dynamic entities inserted by JS: next waypoint arrow + destination flag -->
          <a-entity id="arObjects"></a-entity>

          <!-- A subtle horizon grid for orientation -->
          <a-entity geometry="primitive: ring; radiusInner: 15; radiusOuter: 15.2;" position="0 0 -25" material="opacity:0.15"></a-entity>
        </a-scene>
      </section>

      <!-- Map Panel -->
      <section id="mapPanel">
        <div id="map" class="shimmer"></div>
      </section>
    </main>

    <div class="hud">
      <div class="hud-inner">
        <div class="stats">
          <span class="pill">Status: <strong id="status" class="status-warn">Idle</strong></span>
          <span class="pill">Remaining: <strong id="remain">â€“</strong></span>
          <span class="pill">ETA: <strong id="eta">â€“</strong></span>
          <span class="pill">Next: <strong id="nextStep">â€“</strong></span>
        </div>
        <div class="tip">Tip: For best results, use outdoors with good GPS and hold your phone upright. Host via HTTPS (GitHub Pages).</div>
      </div>
    </div>

    <div id="toast" class="toast"></div>
  </div>

  <script>
    /**
     * Web AR Navigation â€“ single-file demo built for GitHub Pages & mobile browsers.
     * Features:
     *  - Destination search (address or "lat,lon") via OpenStreetMap Nominatim (no key, rate limited)
     *  - Optional custom source (or use your live GPS)
     *  - Routing via OSRM public demo server (walking / driving / bike)
     *  - Live distance remaining + ETA
     *  - AR guidance using AR.js gps-entity-place (next waypoint arrow + destination flag)
     *  - 2D map (Leaflet) with route polyline & you-are-here dot
     *  - Works entirely client-side. HTTPS required for camera & geolocation.
     *
     * Notes:
     *  - Public endpoints are community resources; be gentle. For production, host your own OSRM & Nominatim or use a provider key (Mapbox, Google, etc.).
     *  - iOS Safari needs camera motion/orientation permission; you may need to tap the page.
     */

    const els = {
      form: document.getElementById('routeForm'),
      src: document.getElementById('src'),
      dst: document.getElementById('dst'),
      profile: document.getElementById('profile'),
      toggleView: document.getElementById('toggleView'),
      mapPanel: document.getElementById('mapPanel'),
      arPanel: document.getElementById('arPanel'),
      remain: document.getElementById('remain'),
      eta: document.getElementById('eta'),
      nextStep: document.getElementById('nextStep'),
      status: document.getElementById('status'),
      toast: document.getElementById('toast'),
      arObjects: document.getElementById('arObjects'),
    };

    let map, youMarker, routeLine, routeCoords = [], stepIdx = 0, totalMeters = 0, remainingMeters = 0, lastPosition = null, watchId = null, mode = 'ar';

    const toRad = d => d * Math.PI / 180;
    const toDeg = r => r * 180 / Math.PI;

    function showToast(msg, timeout=2600){
      els.toast.textContent = msg;
      els.toast.style.display = 'block';
      setTimeout(()=> els.toast.style.display='none', timeout);
    }

    function setStatus(text, level='warn'){
      els.status.textContent = text;
      els.status.className = level==='ok' ? 'status-ok' : level==='bad' ? 'status-bad' : 'status-warn';
    }

    function metersToNice(m){
      if (m == null) return 'â€“';
      if (m < 1000) return `${m.toFixed(0)} m`;
      return `${(m/1000).toFixed(2)} km`;
    }

    function etaFromMeters(m, profile){
      // Rough speeds (m/s)
      const v = profile==='driving' ? 13.9 : profile==='bike' ? 4.5 : 1.3; // ~50km/h, ~16km/h, ~4.7km/h
      const s = m / v;
      if (!isFinite(s)) return 'â€“';
      const h = Math.floor(s/3600), min = Math.floor((s%3600)/60);
      const sec = Math.floor(s%60);
      return h>0 ? `${h}h ${min}m` : `${min}m ${sec}s`;
    }

    function haversine(a, b){
      const R=6371000; // m
      const dLat=toRad(b.lat-a.lat), dLon=toRad(b.lon-a.lon);
      const lat1=toRad(a.lat), lat2=toRad(b.lat);
      const h = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.sqrt(h));
    }

    function parseLatLon(input){
      // Accept "lat,lon"
      const m = input.trim().match(/^\s*(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)\s*$/);
      if (!m) return null;
      return { lat: parseFloat(m[1]), lon: parseFloat(m[2]) };
    }

    async function geocode(q){
      // If already lat,lon
      const direct = parseLatLon(q);
      if (direct) return direct;
      const url = `https://nominatim.openstreetmap.org/search?format=json&limit=1&q=${encodeURIComponent(q)}`;
      const res = await fetch(url, { headers: { 'Accept':'application/json' } });
      if (!res.ok) throw new Error('Geocoding failed');
      const data = await res.json();
      if (!data[0]) throw new Error('Place not found');
      return { lat: parseFloat(data[0].lat), lon: parseFloat(data[0].lon) };
    }

    async function route(from, to, profile){
      const prof = profile==='driving' ? 'driving' : (profile==='bike' ? 'bike' : 'foot');
      const url = `https://router.project-osrm.org/route/v1/${prof}/${from.lon},${from.lat};${to.lon},${to.lat}?overview=full&geometries=geojson&steps=true`;
      const res = await fetch(url);
      if (!res.ok) throw new Error('Routing failed');
      const json = await res.json();
      if (!json.routes || !json.routes[0]) throw new Error('No route found');
      const r = json.routes[0];
      // Flatten step coordinates as waypoints ~ every 30-40m for smoother AR guidance
      const coords = r.geometry.coordinates.map(c=>({ lon:c[0], lat:c[1] }));
      return { coords, distance: r.distance, duration: r.duration, steps: r.legs?.[0]?.steps || [] };
    }

    function initMapIfNeeded(center){
      if (map) return;
      map = L.map('map').setView([center.lat, center.lon], 15);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; OpenStreetMap' }).addTo(map);
      youMarker = L.circleMarker([center.lat, center.lon], { radius:6 }).addTo(map);
    }

    function updateMap(position){
      if (!map || !youMarker) return;
      youMarker.setLatLng([position.lat, position.lon]);
    }

    function drawRouteOnMap(coords){
      if (!map) return;
      if (routeLine) routeLine.remove();
      routeLine = L.polyline(coords.map(c=>[c.lat,c.lon])).addTo(map);
      const bounds = routeLine.getBounds();
      map.fitBounds(bounds.pad(0.2));
      document.getElementById('map').classList.remove('shimmer');
    }

    function clearAR(){
      els.arObjects.innerHTML = '';
    }

    function placeDestinationAR(dest){
      const flag = document.createElement('a-entity');
      flag.setAttribute('gps-entity-place', `latitude: ${dest.lat}; longitude: ${dest.lon};`);
      flag.setAttribute('geometry', 'primitive: box; height: 3; width: 0.2; depth: 0.2');
      flag.setAttribute('material', 'color: #70a0ff; opacity: 0.9');
      flag.setAttribute('animation', 'property: position; dir: alternate; dur: 1800; easing: easeInOutSine; loop:true; to: 0 3 0');
      els.arObjects.appendChild(flag);
    }

    let nextArrowEl = null;
    function placeOrMoveNextArrow(next){
      if (!nextArrowEl){
        nextArrowEl = document.createElement('a-entity');
        nextArrowEl.setAttribute('geometry', 'primitive: cone; radiusBottom: 1.2; radiusTop: 0.0; height: 3');
        nextArrowEl.setAttribute('material', 'color: #00d18f; opacity: 0.85');
        els.arObjects.appendChild(nextArrowEl);
      }
      nextArrowEl.setAttribute('gps-entity-place', `latitude: ${next.lat}; longitude: ${next.lon};`);
      // keep it gently pulsing
      nextArrowEl.setAttribute('animation__pulse', 'property: scale; dir: alternate; dur: 1200; easing: easeInOutSine; loop:true; to: 1.2 1.2 1.2');
    }

    function pickNextWaypoint(user, coords, fromIdx){
      // advance until next point is at least ~25m away to make AR target meaningful
      let i = Math.max(0, fromIdx);
      while (i < coords.length){
        const d = haversine(user, coords[i]);
        if (d > 25) return { idx: i, pt: coords[i], dist: d };
        i++;
      }
      // else destination
      return { idx: coords.length-1, pt: coords[coords.length-1], dist: haversine(user, coords[coords.length-1]) };
    }

    function recalcRemaining(user){
      if (!routeCoords.length) return 0;
      // distance from user to next waypoint + remaining polyline length
      let m = haversine(user, routeCoords[stepIdx] || routeCoords[routeCoords.length-1]);
      for (let i=stepIdx; i<routeCoords.length-1; i++){
        m += haversine(routeCoords[i], routeCoords[i+1]);
      }
      remainingMeters = m;
      els.remain.textContent = metersToNice(m);
      els.eta.textContent = etaFromMeters(m, els.profile.value);
      return m;
    }

    function updateNextStepLabel(steps, user){
      if (!steps || !steps.length){ els.nextStep.textContent = 'On route'; return; }
      // naive: choose step whose location is nearest ahead
      let best = null, bestD = Infinity;
      for (const st of steps){
        const c = { lat: st.maneuver.location[1], lon: st.maneuver.location[0] };
        const d = haversine(user, c);
        if (d < bestD){ bestD = d; best = st; }
      }
      if (best){ els.nextStep.textContent = (best.name ? best.maneuver.type+" "+best.name : best.maneuver.type || 'Continue'); }
    }

    async function planRoute(){
      try{
        setStatus('Planning...', 'warn');
        const dstQ = els.dst.value.trim();
        if (!dstQ){ showToast('Enter a destination'); return; }

        const dst = await geocode(dstQ);
        let src;
        const srcQ = els.src.value.trim();
        if (srcQ){ src = await geocode(srcQ); }
        else {
          src = await new Promise((resolve, reject)=>{
            navigator.geolocation.getCurrentPosition(pos=>{
              resolve({ lat: pos.coords.latitude, lon: pos.coords.longitude });
            }, err=> reject(err), { enableHighAccuracy:true, timeout:15000 });
          });
        }

        initMapIfNeeded(src);

        const prof = els.profile.value;
        const r = await route(src, dst, prof);
        routeCoords = r.coords;
        totalMeters = r.distance;
        stepIdx = 0;
        clearAR();
        placeDestinationAR(dst);
        drawRouteOnMap(routeCoords);
        setStatus('Ready. Start moving', 'ok');
        els.nextStep.textContent = 'Follow the arrow';
        document.getElementById('map').classList.remove('shimmer');

        // start GPS tracking
        if (watchId) navigator.geolocation.clearWatch(watchId);
        watchId = navigator.geolocation.watchPosition(onMove, err=>{
          console.warn(err);
          setStatus('GPS error', 'bad');
        }, { enableHighAccuracy:true, maximumAge: 1000, timeout: 15000 });

        lastPlan = { src, dst, steps: r.steps };

      }catch(e){
        console.error(e);
        setStatus('Error', 'bad');
        showToast(e.message || 'Failed');
      }
    }

    let lastPlan = null;

    function onMove(pos){
      const user = { lat: pos.coords.latitude, lon: pos.coords.longitude };
      lastPosition = user;
      updateMap(user);

      if (!routeCoords.length) return;

      // advance stepIdx when close to current target
      const target = routeCoords[stepIdx] || routeCoords[routeCoords.length-1];
      const dToTarget = haversine(user, target);
      if (dToTarget < 15 && stepIdx < routeCoords.length-1){
        stepIdx++;
      }

      // pick a slightly-ahead waypoint to aim at (>=25m)
      const pick = pickNextWaypoint(user, routeCoords, stepIdx);
      stepIdx = pick.idx;
      placeOrMoveNextArrow(pick.pt);

      // update stats
      const rem = recalcRemaining(user);
      updateNextStepLabel(lastPlan?.steps || [], user);

      if (rem < 12){
        setStatus('Arrived ðŸŽ‰', 'ok');
        els.nextStep.textContent = 'You have reached your destination';
        if (watchId){ navigator.geolocation.clearWatch(watchId); watchId = null; }
      } else {
        setStatus('On route', 'ok');
      }
    }

    // Toggle AR/Map view
    els.toggleView.addEventListener('click', ()=>{
      if (mode==='ar'){
        mode='map';
        els.arPanel.style.display='none';
        els.mapPanel.style.display='block';
        els.toggleView.textContent='Show AR';
        if (map && lastPosition) map.setView([lastPosition.lat, lastPosition.lon]);
      } else {
        mode='ar';
        els.mapPanel.style.display='none';
        els.arPanel.style.display='block';
        els.toggleView.textContent='Show Map';
      }
    });

    // Form submit
    els.form.addEventListener('submit', (e)=>{
      e.preventDefault();
      planRoute();
    });

    // iOS device motion permission prompt helper (needed on some versions)
    document.addEventListener('click', async ()=>{
      const any = window.DeviceMotionEvent || window.DeviceOrientationEvent;
      // @ts-ignore
      if (any && typeof any.requestPermission === 'function'){
        try{ await any.requestPermission(); }catch(e){ /* ignore */ }
      }
    }, { once:true });

    // Initial hint if not https
    if (location.protocol !== 'https:' && location.hostname !== 'localhost'){
      showToast('Please host this over HTTPS (GitHub Pages) for camera + GPS access');
    }
  </script>

  <!-- Small helper component to keep camera rotation fresh (fix for some devices) -->
  <script>
    AFRAME.registerComponent('rotation-reader', {
      tick: function () {
        const rot = this.el.getAttribute('rotation');
        // no-op, but forces A-Frame to consider camera updates
      }
    });
  </script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Web AR Navigation (Standards-Only)</title>
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.2.0/mapbox-gl.css" rel="stylesheet" />
  <style>
    :root { color-scheme: light dark; }
    html, body { height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #hud { position: fixed; top: env(safe-area-inset-top, 12px); left: 12px; right: 12px; z-index: 10; display:flex; gap:8px; align-items:center; background: color-mix(in oklab, Canvas 85%, transparent); backdrop-filter: blur(8px); border: 1px solid color-mix(in oklab, CanvasText 20%, transparent); border-radius: 14px; padding: 10px 12px; box-shadow: 0 4px 16px rgba(0,0,0,.1); }
    #status { font-weight: 600; font-size: 14px; }
    #controls { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    #controls input { width: 9rem; padding:.5rem .6rem; border-radius: 10px; border:1px solid color-mix(in oklab, CanvasText 25%, transparent); background: color-mix(in oklab, Canvas 90%, transparent); }
    #controls button { padding:.55rem .8rem; border-radius: 10px; border:1px solid color-mix(in oklab, CanvasText 25%, transparent); background: color-mix(in oklab, AccentColor 20%, Canvas 85%); font-weight:600; }
    #map { position: absolute; inset:0; display:none; }
    #permit { position: fixed; bottom: env(safe-area-inset-bottom, 12px); left: 12px; right: 12px; z-index: 10; text-align:center; font-size: 12px; opacity:.8; }
    canvas { display:block; width:100%; height:100%; }
  </style>
</head>
<body>
  <div id="hud">
    <div id="status">Initializing…</div>
    <div id="controls">
      <label style="font-size:12px; opacity:.7">Dest lat</label><input id="destLat" type="number" step="any" placeholder="e.g. 37.7754" />
      <label style="font-size:12px; opacity:.7">Dest lon</label><input id="destLon" type="number" step="any" placeholder="e.g. -122.4180" />
      <button id="btnRoute" title="Fetch route">Get route</button>
    </div>
  </div>
  <div id="map"></div>
  <div id="permit">Use outdoors. Requires motion+location permissions and HTTPS. If AR isn’t available, a live 2D map fallback will appear.</div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { ARButton } from 'https://unpkg.com/three@0.160.0/examples/jsm/webxr/ARButton.js';

    const MAPBOX_TOKEN = 'YOUR_MAPBOX_ACCESS_TOKEN';

    const state = {
      hasXR: 'xr' in navigator,
      renderer: null, scene: null, camera: null,
      guides: null,
      distanceBoard: null,
      originLLA: null, currentLLA: null,
      routeLLA: [],
      nextIdx: 0,
      routeRemainFromIdx: [],
      map: null,
      watchId: null,
    };

    const ui = {
      status: document.getElementById('status'),
      mapEl: document.getElementById('map'),
      destLat: document.getElementById('destLat'),
      destLon: document.getElementById('destLon'),
      btnRoute: document.getElementById('btnRoute'),
    };

    const R = 6378137;
    function ll2enu(lat, lon, lat0, lon0){
      const dLat = (lat - lat0) * Math.PI/180;
      const dLon = (lon - lon0) * Math.PI/180;
      const x = R * dLon * Math.cos(((lat+lat0)*0.5) * Math.PI/180);
      const z = -R * dLat;
      return { x, z };
    }
    function haversine(a, b){
      const dLat = (b.lat-a.lat)*Math.PI/180;
      const dLon = (b.lon-a.lon)*Math.PI/180;
      const la1 = a.lat*Math.PI/180, la2 = b.lat*Math.PI/180;
      const h = Math.sin(dLat/2)**2 + Math.cos(la1)*Math.cos(la2)*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.min(1, Math.sqrt(h)));
    }

    const ORS_API_KEY = 'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6ImE0MzE1ZTY1YmIyZjQzNmJhMzU1NjEzMWRkOGE2YTI1IiwiaCI6Im11cm11cjY0In0=';

    async function fetchRoute(origin, dest){
      try {
        const params = new URLSearchParams({
          api_key: ORS_API_KEY,
          start: `${origin.lon},${origin.lat}`,
          end:   `${dest.lon},${dest.lat}`
        });
        const orsUrl = `https://api.openrouteservice.org/v2/directions/foot-walking?${params.toString()}`;
        const orsRes = await fetch(orsUrl, { mode: 'cors' });
        if (!orsRes.ok) throw new Error(await orsRes.text());
        const orsJson = await orsRes.json();
        const feat = orsJson.features?.[0];
        if (!feat) throw new Error('ORS returned no route');
        return feat.geometry.coordinates.map(([lon, lat]) => ({ lat, lon }));
      } catch (e) {
        console.warn('ORS failed, falling back to OSRM:', e);
      }
      const osrmUrl = `https://router.project-osrm.org/route/v1/foot/${origin.lon},${origin.lat};${dest.lon},${dest.lat}?overview=full&geometries=geojson&steps=true`;
      const osrmRes = await fetch(osrmUrl, { mode: 'cors' });
      if (!osrmRes.ok) throw new Error(await osrmRes.text());
      const osrmJson = await osrmRes.json();
      if (osrmJson.code !== 'Ok' || !osrmJson.routes?.[0]) throw new Error('OSRM returned no route');
      return osrmJson.routes[0].geometry.coordinates.map(([lon, lat]) => ({ lat, lon }));
    }

    function createChevronStrip(count = 10, spacing = 0.9) {
      const group = new THREE.Group();
      const shape = new THREE.Shape();
      shape.moveTo(-0.35, 0);
      shape.lineTo(0, 0.35);
      shape.lineTo(0.35, 0);
      shape.lineTo(0, -0.35);
      shape.lineTo(-0.35, 0);
      const geo = new THREE.ExtrudeGeometry(shape, { depth: 0.02, bevelEnabled: false });
      const mat = new THREE.MeshStandardMaterial({
        color: 0x2eea5a,
        metalness: 0.0,
        roughness: 0.35,
        emissive: 0x0b5d1d,
        emissiveIntensity: 0.85,
        transparent: true,
        opacity: 0.95
      });
      for (let i = 0; i < count; i++) {
        const m = new THREE.Mesh(geo, mat);
        m.rotation.x = -Math.PI / 2;
        m.position.z = -1.2 - i * spacing;
        m.position.y = -0.18 + i * 0.01;
        const s = 1.0 - i * 0.05;
        m.scale.set(s, s, 1);
        group.add(m);
      }
      return group;
    }

    function createDistanceBoard(){
      const canvas = document.createElement('canvas');
      canvas.width = 512; canvas.height = 256;
      const ctx = canvas.getContext('2d');
      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
      const geometry = new THREE.PlaneGeometry(0.9, 0.45);
      const mesh = new THREE.Mesh(geometry, material);
      mesh.userData.draw = (text) => {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = 'rgba(0,0,0,0.55)';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.strokeStyle = 'rgba(255,255,255,0.85)';
        ctx.lineWidth = 6;
        ctx.strokeRect(4,4,canvas.width-8,canvas.height-8);
        ctx.fillStyle = 'white';
        ctx.font = 'bold 48px system-ui, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, canvas.width/2, canvas.height/2);
        texture.needsUpdate = true;
      };
      return mesh;
    }

    function initThree(){
      state.renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
      state.renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      state.renderer.setSize(innerWidth, innerHeight);
      state.renderer.xr.enabled = true;
      document.body.appendChild(state.renderer.domElement);

      state.scene = new THREE.Scene();
      state.camera = new THREE.PerspectiveCamera();

      const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
      state.scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(1,2,1); state.scene.add(dir);

      const chevrons = createChevronStrip(10, 0.9);
      chevrons.position.set(0, -0.2, -1.5);
      state.scene.add(chevrons);
      state.guides = chevrons;

      state.distanceBoard = createDistanceBoard();
      state.distanceBoard.position.set(0, 0.15, -1.0);
      state.distanceBoard.userData.draw('—');
      state.scene.add(state.distanceBoard);

      window.addEventListener('resize', () => {
        state.renderer.setSize(innerWidth, innerHeight);
      });

      const btn = ARButton.createButton(state.renderer, { requiredFeatures:['hit-test'] });
      document.body.appendChild(btn);

      state.renderer.setAnimationLoop(onXRFrame);
    }

    function onXRFrame(){
      if (!state.currentLLA || state.routeLLA.length === 0){
        state.renderer.render(state.scene, state.camera);
        return;
      }

      const target = state.routeLLA[Math.min(state.nextIdx, state.routeLLA.length-1)];
      const enu = ll2enu(target.lat, target.lon, state.currentLLA.lat, state.currentLLA.lon);

      const v = new THREE.Vector3(enu.x, 0, enu.z).applyMatrix4(state.camera.matrixWorldInverse);
      const yaw = Math.atan2(v.x, -v.z);
      state.guides.rotation.set(0, 0, yaw);

      const dist = Math.hypot(enu.x, enu.z);
      const tail = state.routeRemainFromIdx[state.nextIdx] ?? 0;
      const remaining = dist + tail;

      ui.status.textContent = `Next: ${dist.toFixed(1)} m | waypoint ${state.nextIdx+1}/${state.routeLLA.length}`;

      const text = remaining > 1000 ? `Remaining: ${(remaining/1000).toFixed(2)} km` : `Remaining: ${Math.round(remaining)} m`;
      state.distanceBoard.userData.draw(text);
      state.distanceBoard.quaternion.copy(state.camera.quaternion);
      state.distanceBoard.position.set(0, 0.15, -1.0);

      if (dist < 5 && state.nextIdx < state.routeLLA.length-1) state.nextIdx++;

      state.renderer.render(state.scene, state.camera);
    }

    function startGeolocation(){
      if (!navigator.geolocation){ ui.status.textContent = 'Geolocation unavailable'; return; }
      state.watchId = navigator.geolocation.watchPosition(p => {
        const { latitude:lat, longitude:lon } = p.coords;
        state.currentLLA = { lat, lon };
        if (!state.originLLA) state.originLLA = { lat, lon };
        if (state.map){
          state.map.easeTo({ center:[lon,lat], duration:500 });
        }
      }, err => {
        ui.status.textContent = 'Location error: ' + err.message;
      }, { enableHighAccuracy:true, maximumAge:1000, timeout:8000 });
    }

    async function ensureMapFallback(){
      if (state.hasXR) return;
      ui.status.textContent = 'AR not supported — showing map';
      ui.mapEl.style.display = 'block';

      if (!MAPBOX_TOKEN || MAPBOX_TOKEN === 'YOUR_MAPBOX_ACCESS_TOKEN'){
        ui.status.textContent = 'Map fallback needs a Mapbox token.';
        return;
      }

      await import('https://api.mapbox.com/mapbox-gl-js/v3.2.0/mapbox-gl.js');
      mapboxgl.accessToken = MAPBOX_TOKEN;
      state.map = new mapboxgl.Map({
        container: ui.mapEl,
        style: 'mapbox://styles/mapbox/streets-v12',
        center: [0,0], zoom:16
      });
      state.map.addControl(new mapboxgl.NavigationControl());
      state.map.on('load', () => {
        if (state.currentLLA){
          state.map.jumpTo({ center:[state.currentLLA.lon,state.currentLLA.lat] });
        }
      });
    }

    async function setRouteTo(dest){
      if (!state.currentLLA){ ui.status.textContent = 'Waiting for GPS…'; return; }
      try{
        ui.status.textContent = 'Fetching route…';
        const route = await fetchRoute(state.currentLLA, dest);
        state.routeLLA = route;
        state.nextIdx = 0;

        state.routeRemainFromIdx = new Array(route.length).fill(0);
        let sum = 0;
        for (let i = route.length-1; i > 0; i--){
          sum += haversine(route[i-1], route[i]);
          state.routeRemainFromIdx[i-1] = sum;
        }

        ui.status.textContent = `Route ready: ${route.length} points.`;

        if (state.map){
          const coords = route.map(p => [p.lon,p.lat]);
          const line = { type:'Feature', geometry:{ type:'LineString', coordinates:coords } };
          if (!state.map.getSource('route')){
            state.map.addSource('route',{ type:'geojson', data:line });
            state.map.addLayer({ id:'routeLine', type:'line', source:'route', paint:{ 'line-width':5, 'line-color':'#3b82f6' } });
          } else {
            state.map.getSource('route').setData(line);
          }
          const bounds = coords.reduce((b,c)=>b.extend(c), new mapboxgl.LngLatBounds(coords[0], coords[0]));
          state.map.fitBounds(bounds, { padding:32, duration:800 });
        }

      }catch(e){
        ui.status.textContent = 'Routing error: ' + e.message;
      }
    }

    ui.btnRoute.addEventListener('click', () => {
      const lat = parseFloat(ui.destLat.value);
      const lon = parseFloat(ui.destLon.value);
      if (Number.isFinite(lat) && Number.isFinite(lon)) setRouteTo({lat,lon});
      else ui.status.textContent = 'Enter valid lat/lon';
    });

    startGeolocation();
    if (state.hasXR){ initThree(); ui.status.textContent = 'Tap Enter AR, then pick destination.'; }
    await ensureMapFallback();

    ui.destLat.value = '37.7754';
    ui.destLon.value = '-122.4180';
  </script>
</body>
</html>

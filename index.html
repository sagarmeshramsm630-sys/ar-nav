<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Web AR Navigation (Standards‑Only)</title>
  <!-- Mapbox GL JS (fallback map + routing fetch) -->
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.2.0/mapbox-gl.css" rel="stylesheet" />
  <style>
    :root { color-scheme: light dark; }
    html, body { height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #hud { position: fixed; top: env(safe-area-inset-top, 12px); left: 12px; right: 12px; z-index: 10; display:flex; gap:8px; align-items:center; background: color-mix(in oklab, Canvas 85%, transparent); backdrop-filter: blur(8px); border: 1px solid color-mix(in oklab, CanvasText 20%, transparent); border-radius: 14px; padding: 10px 12px; box-shadow: 0 4px 16px rgba(0,0,0,.1); }
    #status { font-weight: 600; font-size: 14px; }
    #controls { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    #controls input { width: 9rem; padding:.5rem .6rem; border-radius: 10px; border:1px solid color-mix(in oklab, CanvasText 25%, transparent); background: color-mix(in oklab, Canvas 90%, transparent); }
    #controls button { padding:.55rem .8rem; border-radius: 10px; border:1px solid color-mix(in oklab, CanvasText 25%, transparent); background: color-mix(in oklab, AccentColor 20%, Canvas 85%); font-weight:600; }
    #map { position: absolute; inset:0; display:none; }
    #permit { position: fixed; bottom: env(safe-area-inset-bottom, 12px); left: 12px; right: 12px; z-index: 10; text-align:center; font-size: 12px; opacity:.8; }
    /* three.js canvas fills page beneath HUD */
    canvas { display:block; width:100%; height:100%; }
  </style>
</head>
<body>
  <div id="hud">
    <div id="status">Initializing…</div>
    <div id="controls">
      <label style="font-size:12px; opacity:.7">Dest lat</label><input id="destLat" type="number" step="any" placeholder="e.g. 37.7754" />
      <label style="font-size:12px; opacity:.7">Dest lon</label><input id="destLon" type="number" step="any" placeholder="e.g. -122.4180" />
      <button id="btnRoute" title="Fetch route">Get route</button>
    </div>
  </div>
  <div id="map"></div>
  <div id="permit">Use outdoors. Requires motion+location permissions and HTTPS. If AR isn’t available, a live 2D map fallback will appear.</div>

  <!-- three.js + WebXR (module form) -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { ARButton } from 'https://unpkg.com/three@0.160.0/examples/jsm/webxr/ARButton.js';

    /* =========================
       CONFIG — fill in your Mapbox token
       ========================= */
    const MAPBOX_TOKEN = 'YOUR_MAPBOX_ACCESS_TOKEN'; // TODO: replace

    /* =========================
       STATE
       ========================= */
    const state = {
      hasXR: 'xr' in navigator,
      renderer: null, scene: null, camera: null,
      arrow: null, arrowLabel: null,
      originLLA: null, currentLLA: null,
      routeLLA: [], // {lat, lon}
      nextIdx: 0,
      map: null, mapLine: null,
      watchId: null,
    };

    const ui = {
      status: document.getElementById('status'),
      mapEl: document.getElementById('map'),
      destLat: document.getElementById('destLat'),
      destLon: document.getElementById('destLon'),
      btnRoute: document.getElementById('btnRoute'),
    };

    /* =========================
       GEO + MATH HELPERS
       ========================= */
    const R = 6378137; // WGS84 radius in meters
    function ll2enu(lat, lon, lat0, lon0){
      const dLat = (lat - lat0) * Math.PI/180;
      const dLon = (lon - lon0) * Math.PI/180;
      const x = R * dLon * Math.cos(((lat+lat0)*0.5) * Math.PI/180); // East
      const z = -R * dLat; // North -> -Z forward in Three
      return { x, z };
    }
    function haversine(a, b){
      const dLat = (b.lat-a.lat)*Math.PI/180;
      const dLon = (b.lon-a.lon)*Math.PI/180;
      const la1 = a.lat*Math.PI/180, la2 = b.lat*Math.PI/180;
      const h = Math.sin(dLat/2)**2 + Math.cos(la1)*Math.cos(la2)*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.min(1, Math.sqrt(h)));
    }

    /* =========================
       MAPBOX ROUTING (GeoJSON geometry)
       ========================= */
    // ✅ Free routing using ORS (no card needed) + OSRM fallback
const ORS_API_KEY = 'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6ImE0MzE1ZTY1YmIyZjQzNmJhMzU1NjEzMWRkOGE2YTI1IiwiaCI6Im11cm11cjY0In0='; // ✅ your key here (in quotes)

// Drop-in replacement: ORS first, OSRM fallback (no key)
async function fetchRoute(origin, dest){
  // --- 1) Try ORS (GET, simpler on mobile) ---
  try {
    const params = new URLSearchParams({
      api_key: ORS_API_KEY,                       // keep your key in quotes
      start: `${origin.lon},${origin.lat}`,       // NOTE: lon,lat order
      end:   `${dest.lon},${dest.lat}`
    });
    const orsUrl = `https://api.openrouteservice.org/v2/directions/foot-walking?${params.toString()}`;
    const orsRes = await fetch(orsUrl, { mode: 'cors' });
    if (!orsRes.ok) {
      const msg = await orsRes.text().catch(()=> '');
      throw new Error(`ORS ${orsRes.status}: ${msg.slice(0,160)}`);
    }
    const orsJson = await orsRes.json();
    const feat = orsJson.features?.[0];
    if (!feat) throw new Error('ORS returned no route');
    return feat.geometry.coordinates.map(([lon, lat]) => ({ lat, lon }));
  } catch (e) {
    console.warn('ORS failed, falling back to OSRM:', e);
  }

  // --- 2) Fallback to OSRM (no key) ---
  const osrmUrl = `https://router.project-osrm.org/route/v1/foot/${origin.lon},${origin.lat};${dest.lon},${dest.lat}?overview=full&geometries=geojson&steps=true`;
  const osrmRes = await fetch(osrmUrl, { mode: 'cors' });
  if (!osrmRes.ok) {
    const msg = await osrmRes.text().catch(()=> '');
    throw new Error(`OSRM ${osrmRes.status}: ${msg.slice(0,160)}`);
  }
  const osrmJson = await osrmRes.json();
  if (osrmJson.code !== 'Ok' || !osrmJson.routes?.[0]) {
    throw new Error('OSRM returned no route');
  }
  const coords = osrmJson.routes[0].geometry.coordinates;
  return coords.map(([lon, lat]) => ({ lat, lon }));
}


    /* =========================
       WEBXR / THREE SETUP
       ========================= */
     
     // Build a strip of glowing chevrons (like HUD lanes)

function createChevronStrip(count = 10, spacing = 0.9) {
  const group = new THREE.Group();

  // diamond/chevron shape
  const shape = new THREE.Shape();
  shape.moveTo(-0.35, 0);
  shape.lineTo(0, 0.35);
  shape.lineTo(0.35, 0);
  shape.lineTo(0, -0.35);
  shape.lineTo(-0.35, 0);

  const geo = new THREE.ExtrudeGeometry(shape, { depth: 0.02, bevelEnabled: false });

  // slightly glowy green look
  const mat = new THREE.MeshStandardMaterial({
    color: 0x2eea5a,
    metalness: 0.0,
    roughness: 0.35,
    emissive: 0x0b5d1d,
    emissiveIntensity: 0.85,
    transparent: true,
    opacity: 0.95
  });

  for (let i = 0; i < count; i++) {
    const m = new THREE.Mesh(geo, mat);
    m.rotation.x = -Math.PI / 2;            // lay flat on ground
    m.position.z = -1.2 - i * spacing;      // push forward from camera
    m.position.y = -0.18 + i * 0.01;        // slight taper up
    const s = 1.0 - i * 0.05;               // smaller further away
    m.scale.set(s, s, 1);
    group.add(m);
  }
  return group;
}
  // ---- remaining distance (meters) from current point to the end of the route
function remainingDistanceMeters(current, route, idx){
  if (!current || route.length === 0) return 0;
  let m = 0;
  // from current position to next waypoint
  if (idx < route.length){
    m += haversine(current, route[idx]); // meters (uses your existing haversine)
  }
  // from next waypoint to the end
  for (let i = idx; i < route.length - 1; i++){
    m += haversine(route[i], route[i+1]);
  }
  return m;
}

// ---- make a floating text board using a CanvasTexture
function createDistanceBoard(){
  const canvas = document.createElement('canvas');
  canvas.width = 512; canvas.height = 256;
  const ctx = canvas.getContext('2d');

  function draw(text){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // background
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    // border
    ctx.strokeStyle = 'rgba(255,255,255,0.85)';
    ctx.lineWidth = 6;
    ctx.strokeRect(4,4,canvas.width-8,canvas.height-8);
    // label
    ctx.fillStyle = 'white';
    ctx.font = 'bold 48px system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, canvas.width/2, canvas.height/2);
    texture.needsUpdate = true;
  }

  const texture = new THREE.CanvasTexture(canvas);
  texture.minFilter = THREE.LinearFilter;
  const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
  const geometry = new THREE.PlaneGeometry(0.9, 0.45); // ~90cm x 45cm at 1m
  const mesh = new THREE.Mesh(geometry, material);
  mesh.userData.draw = draw;
  return mesh;
}

    function initThree(){
      state.renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
      state.renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      state.renderer.setSize(innerWidth, innerHeight);
      state.renderer.xr.enabled = true;
      document.body.appendChild(state.renderer.domElement);

      state.scene = new THREE.Scene();
      state.camera = new THREE.PerspectiveCamera();

      const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
      state.scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(1,2,1); state.scene.add(dir);

      
      // Chevron lane instead of cone arrow
      const chevrons = createChevronStrip(10, 0.9);
      chevrons.position.set(0, -0.2, -1.5);
      state.scene.add(chevrons);
      state.guides = chevrons;    // store reference
       // after you add chevrons (or your arrow) to the scene:
      state.distanceBoard = createDistanceBoard();
      state.distanceBoard.position.set(0, 0.15, -1.0); // a bit above center, ~1m ahead
      state.scene.add(state.distanceBoard);
      // initial text
       state.distanceBoard.userData.draw('—');


      window.addEventListener('resize', () => {
        state.renderer.setSize(innerWidth, innerHeight);
      });

      const btn = ARButton.createButton(state.renderer, { requiredFeatures:['hit-test'] });
      document.body.appendChild(btn);

      state.renderer.setAnimationLoop(onXRFrame);
    }

    function onXRFrame(t, frame){
      if (!state.currentLLA || state.routeLLA.length === 0){
        state.renderer.render(state.scene, state.camera);
        return;
      }
      // pick next target
      const target = state.routeLLA[Math.min(state.nextIdx, state.routeLLA.length-1)];
      const enu = ll2enu(target.lat, target.lon, state.currentLLA.lat, state.currentLLA.lon);

      // rotate arrow to face target relative to camera
      const targetVec = new THREE.Vector3(enu.x, 0, enu.z).applyMatrix4(state.camera.matrixWorldInverse);
      const yaw = Math.atan2(targetVec.x, -targetVec.z); // right-handed
      // OLD:
      // state.arrow.rotation.set(-Math.PI/2, 0, yaw);

      // NEW:
      state.guides.rotation.set(0, 0, yaw);


      // advance when close
      const dist = Math.hypot(enu.x, enu.z);
      ui.status.textContent = `Next: ${dist.toFixed(1)} m | waypoint ${state.nextIdx+1}/${state.routeLLA.length}`;
      // total remaining distance (to destination, not just next waypoint)
const remainingM = remainingDistanceMeters(state.currentLLA, state.routeLLA, state.nextIdx);

// pretty print
let label;
if (remainingM >= 1000) {
  label = `Remaining: ${(remainingM/1000).toFixed(2)} km`;
} else {
  label = `Remaining: ${Math.max(0, Math.round(remainingM))} m`;
}
state.distanceBoard.userData.draw(label);

// keep the board facing the camera (billboard)
state.distanceBoard.quaternion.copy(state.camera.quaternion);
// keep it ~1m in front of camera
state.distanceBoard.position.set(0, 0.15, -1.0);

      if (dist < 5 && state.nextIdx < state.routeLLA.length-1) state.nextIdx++;

      state.renderer.render(state.scene, state.camera);
    }

    /* =========================
       GEOLOCATION + MAP FALLBACK
       ========================= */
    function startGeolocation(){
      if (!navigator.geolocation){ ui.status.textContent = 'Geolocation unavailable'; return; }
      state.watchId = navigator.geolocation.watchPosition(p => {
        const { latitude:lat, longitude:lon } = p.coords;
        state.currentLLA = { lat, lon };
        if (!state.originLLA) state.originLLA = { lat, lon };
        // update map marker when in fallback
        if (state.map){
          const center = [lon, lat];
          state.map.easeTo({ center, duration: 500 });
        }
      }, err => {
        ui.status.textContent = 'Location error: ' + err.message;
      }, { enableHighAccuracy:true, maximumAge: 1000, timeout: 8000 });
    }

    async function ensureMapFallback(){
      if (state.hasXR) return; // only if no WebXR
      ui.status.textContent = 'AR not supported here — showing map fallback';
      ui.mapEl.style.display = 'block';

      // lazy‑load Mapbox GL JS only if needed
      await import('https://api.mapbox.com/mapbox-gl-js/v3.2.0/mapbox-gl.js');
      // @ts-ignore global injected
      mapboxgl.accessToken = MAPBOX_TOKEN;
      state.map = new mapboxgl.Map({
        container: ui.mapEl,
        style: 'mapbox://styles/mapbox/streets-v12',
        center: [0,0], zoom: 16
      });
      state.map.addControl(new mapboxgl.NavigationControl());

      state.map.on('load', () => {
        if (!state.currentLLA) return;
        state.map.jumpTo({ center: [state.currentLLA.lon, state.currentLLA.lat] });
      });
    }

    /* =========================
       ROUTE HANDLERS
       ========================= */
    async function setRouteTo(dest){
      if (!state.currentLLA){ ui.status.textContent = 'Waiting for GPS fix…'; return; }
      try{
        ui.status.textContent = 'Fetching route…';
        state.routeLLA = await fetchRoute(state.currentLLA, dest);
        state.nextIdx = 0;
        ui.status.textContent = `Route ready: ${state.routeLLA.length} points.`;
        // draw on fallback map
        if (state.map){
          const coords = state.routeLLA.map(p => [p.lon, p.lat]);
          const line = { type:'Feature', geometry:{ type:'LineString', coordinates: coords } };
          if (!state.map.getSource('route')){
            state.map.addSource('route', { type:'geojson', data: line });
            state.map.addLayer({ id:'routeLine', type:'line', source:'route', paint:{ 'line-width':5, 'line-color':'#3b82f6' } });
          } else {
            // @ts-ignore
            state.map.getSource('route').setData(line);
          }
          const bounds = coords.reduce((b, c) => b.extend(c), new mapboxgl.LngLatBounds(coords[0], coords[0]));
          state.map.fitBounds(bounds, { padding: 32, duration: 800 });
        }
      }catch(e){ ui.status.textContent = 'Routing error: ' + e.message; }
    }

    /* =========================
       UI WIRING
       ========================= */
    ui.btnRoute.addEventListener('click', () => {
      const lat = parseFloat(ui.destLat.value); const lon = parseFloat(ui.destLon.value);
      if (Number.isFinite(lat) && Number.isFinite(lon)) setRouteTo({ lat, lon });
      else ui.status.textContent = 'Enter valid destination lat/lon';
    });

    /* =========================
       BOOT
       ========================= */
    startGeolocation();
    if (state.hasXR) { initThree(); ui.status.textContent = 'Tap “Enter AR” then pick a destination.'; }
    await ensureMapFallback();

    // Helpful defaults for quick test (San Francisco block demo)
    ui.destLat.value = '37.7754';
    ui.destLon.value = '-122.4180';
  </script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Web AR Navigation</title>
  <!-- Mapbox GL JS (fallback map + routing fetch) -->
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.2.0/mapbox-gl.css" rel="stylesheet" />
  <style>
    /* Use Inter font for a modern look */
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
    :root { color-scheme: light dark; }
    html, body { 
      height:100%; 
      margin:0; 
      font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, sans-serif; 
      background-color: #000;
    }
    
    /* Responsive HUD */
    #hud { 
      position: fixed; 
      top: env(safe-area-inset-top, 12px); 
      left: 12px; 
      right: 12px; 
      z-index: 10; 
      display:flex; 
      flex-wrap: wrap; /* Ensure responsiveness */
      gap: 12px; 
      align-items:center; 
      background: rgba(17, 24, 39, 0.85); /* Dark background */
      color: #fff;
      backdrop-filter: blur(10px); 
      border: 1px solid rgba(255, 255, 255, 0.15); 
      border-radius: 16px; 
      padding: 14px 16px; 
      box-shadow: 0 8px 30px rgba(0,0,0,.4); 
    }

    #status { 
      font-weight: 700; 
      font-size: 16px; 
      flex-basis: 100%; 
      margin-bottom: 4px;
      color: #34d399; /* Green accent for status */
    }

    #controls { 
      display:flex; 
      gap:8px; 
      align-items:center; 
      flex-grow: 1; /* Allow controls to take up space */
    }
    
    #controls label {
        font-size: 11px; 
        opacity: .7; 
        white-space: nowrap;
    }

    #controls input { 
      width: 7rem; 
      padding:.6rem .8rem; 
      border-radius: 12px; 
      border:1px solid rgba(255, 255, 255, 0.3); 
      background: rgba(255, 255, 255, 0.1); 
      color: #fff;
      transition: all 0.2s;
    }
    
    #controls input::placeholder {
        color: rgba(255, 255, 255, 0.5);
    }
    
    #controls input:focus {
        border-color: #34d399;
        background: rgba(255, 255, 255, 0.15);
        outline: none;
    }

    #controls button { 
      padding:.7rem 1.2rem; 
      border-radius: 12px; 
      border: none;
      background: #34d399; /* Tailwind-like green */
      color: #111827; /* Dark text for contrast */
      font-weight:700; 
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(52, 211, 153, 0.3);
      transition: background-color 0.2s;
    }

    #controls button:hover {
        background: #10b981;
    }

    #map { 
      position: absolute; 
      inset:0; 
      display:none; 
    }
    
    #permit { 
      position: fixed; 
      bottom: env(safe-area-inset-bottom, 12px); 
      left: 12px; 
      right: 12px; 
      z-index: 10; 
      text-align:center; 
      font-size: 12px; 
      opacity:.8;
      color: #ccc;
    }
    
    /* three.js canvas fills page beneath HUD */
    canvas { display:block; width:100%; height:100%; }
    
    @media (max-width: 640px) {
        #hud {
            flex-direction: column;
            align-items: stretch;
        }
        #controls {
            flex-direction: column;
            align-items: stretch;
            gap: 10px;
        }
        #controls div {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        #controls input {
            width: 60%;
            flex-grow: 1;
        }
        #controls button {
            width: 100%;
        }
    }
  </style>
</head>
<body>
  <div id="hud">
    <div id="status">Initializing…</div>
    <div id="controls">
      <div>
        <label for="destLat">Dest Latitude</label>
        <input id="destLat" type="number" step="any" placeholder="e.g. 37.7754" />
      </div>
      <div>
        <label for="destLon">Dest Longitude</label>
        <input id="destLon" type="number" step="any" placeholder="e.g. -122.4180" />
      </div>
      <button id="btnRoute" title="Fetch route">Get Route</button>
    </div>
  </div>
  <div id="map"></div>
  <div id="permit">Use outdoors. Requires motion+location permissions and HTTPS. If AR isn’t available, a live 2D map fallback will appear.</div>

  <!-- three.js + WebXR (module form) -->
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
    import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/ARButton.js';

    /* =========================
       CONFIG 
       ========================= */
    // Mapbox token needed for the 2D map fallback
    const MAPBOX_TOKEN = 'YOUR_MAPBOX_ACCESS_TOKEN'; // <<< Replace with your actual Mapbox token

    /* =========================
       STATE
       ========================= */
    const state = {
      hasXR: 'xr' in navigator,
      renderer: null, scene: null, camera: null,
      arrow: null, arrowLabel: null,
      originLLA: null, currentLLA: null,
      routeLLA: [], // {lat, lon}
      nextIdx: 0,
      map: null, mapLine: null,
      watchId: null,
      guides: null, // Reference to the chevron strip group
      distanceBoard: null, // Reference to the floating text board
    };

    const ui = {
      status: document.getElementById('status'),
      mapEl: document.getElementById('map'),
      destLat: document.getElementById('destLat'),
      destLon: document.getElementById('destLon'),
      btnRoute: document.getElementById('btnRoute'),
    };

    /* =========================
       GEO + MATH HELPERS
       ========================= */
    const R = 6378137; // WGS84 radius in meters
    function ll2enu(lat, lon, lat0, lon0){
      const dLat = (lat - lat0) * Math.PI/180;
      const dLon = (lon - lon0) * Math.PI/180;
      // East (X) is positive, North (Z) is negative (Three.js convention)
      const x = R * dLon * Math.cos(((lat+lat0)*0.5) * Math.PI/180); // East
      const z = -R * dLat; // North -> -Z forward in Three
      return { x, z };
    }
    
    // Haversine distance for remaining route length
    function haversine(a, b){
      const dLat = (b.lat-a.lat)*Math.PI/180;
      const dLon = (b.lon-a.lon)*Math.PI/180;
      const la1 = a.lat*Math.PI/180, la2 = b.lat*Math.PI/180;
      const h = Math.sin(dLat/2)**2 + Math.cos(la1)*Math.cos(la2)*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.min(1, Math.sqrt(h)));
    }

    /* =========================
       ROUTING (GeoJSON geometry)
       ========================= */
    
    // Using OSRM (Open Source Routing Machine) as it requires no API key for basic routing.
    async function fetchRoute(origin, dest){
      // NOTE: OSRM uses lon,lat order for coordinates in the URL
      const osrmUrl = `https://router.project-osrm.org/route/v1/foot/${origin.lon},${origin.lat};${dest.lon},${dest.lat}?overview=full&geometries=geojson&steps=true`;
      const osrmRes = await fetch(osrmUrl, { mode: 'cors' });
      
      if (!osrmRes.ok) {
        const msg = await osrmRes.text().catch(()=> '');
        throw new Error(`Routing service error (OSRM ${osrmRes.status}): ${msg.slice(0,160)}`);
      }
      
      const osrmJson = await osrmRes.json();
      if (osrmJson.code !== 'Ok' || !osrmJson.routes?.[0]) {
        throw new Error('OSRM returned no valid route. Try a different destination.');
      }
      
      const coords = osrmJson.routes[0].geometry.coordinates;
      // Convert [lon, lat] pairs to { lat, lon } objects
      return coords.map(([lon, lat]) => ({ lat, lon }));
    }


    /* =========================
       WEBXR / THREE SETUP
       ========================= */
     
    // Build a strip of glowing chevrons
    function createChevronStrip(count = 10, spacing = 0.9) {
      const group = new THREE.Group();

      // diamond/chevron shape
      const shape = new THREE.Shape();
      shape.moveTo(-0.35, 0);
      shape.lineTo(0, 0.35);
      shape.lineTo(0.35, 0);
      shape.lineTo(0, -0.35);
      shape.lineTo(-0.35, 0);

      const geo = new THREE.ExtrudeGeometry(shape, { depth: 0.02, bevelEnabled: false });

      // slightly glowy green look
      const mat = new THREE.MeshStandardMaterial({
        color: 0x2eea5a,
        metalness: 0.0,
        roughness: 0.35,
        emissive: 0x0b5d1d,
        emissiveIntensity: 0.85,
        transparent: true,
        opacity: 0.95
      });

      for (let i = 0; i < count; i++) {
        const m = new THREE.Mesh(geo, mat);
        m.rotation.x = -Math.PI / 2;            // lay flat on ground
        m.position.z = -1.2 - i * spacing;      // push forward (down -Z) from camera
        m.position.y = -0.18 + i * 0.01;        // slight taper up
        const s = 1.0 - i * 0.05;               // smaller further away
        m.scale.set(s, s, 1);
        group.add(m);
      }
      return group;
    }
    
    // Remaining distance (meters) from current point to the end of the route
    function remainingDistanceMeters(current, route, idx){
      if (!current || route.length === 0) return 0;
      let m = 0;
      // from current position to next waypoint
      if (idx < route.length){
        m += haversine(current, route[idx]); 
      }
      // from next waypoint to the end
      for (let i = idx; i < route.length - 1; i++){
        m += haversine(route[i], route[i+1]);
      }
      return m;
    }

    // make a floating text board using a CanvasTexture
    function createDistanceBoard(){
      const canvas = document.createElement('canvas');
      canvas.width = 512; canvas.height = 256;
      const ctx = canvas.getContext('2d');

      function draw(text){
        ctx.clearRect(0,0,canvas.width,canvas.height);
        // background
        ctx.fillStyle = 'rgba(0,0,0,0.65)';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        // border
        ctx.strokeStyle = '#34d399';
        ctx.lineWidth = 10;
        ctx.strokeRect(4,4,canvas.width-8,canvas.height-8);
        // label
        ctx.fillStyle = 'white';
        ctx.font = 'bold 64px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, canvas.width/2, canvas.height/2);
        texture.needsUpdate = true;
      }

      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
      const geometry = new THREE.PlaneGeometry(0.9, 0.45); // ~90cm x 45cm at 1m
      const mesh = new THREE.Mesh(geometry, material);
      mesh.userData.draw = draw;
      return mesh;
    }

    function initThree(){
      state.renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
      state.renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      state.renderer.setSize(innerWidth, innerHeight);
      state.renderer.xr.enabled = true;
      document.body.appendChild(state.renderer.domElement);

      state.scene = new THREE.Scene();
      state.camera = new THREE.PerspectiveCamera();

      // Lighting
      const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
      state.scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(1,2,1); state.scene.add(dir);

      // Create and place the chevron lane and distance board
      const chevrons = createChevronStrip(10, 0.9);
      chevrons.position.set(0, -0.2, -1.5); // Slightly below the horizon
      state.scene.add(chevrons);
      state.guides = chevrons;    // store reference
      
      state.distanceBoard = createDistanceBoard();
      state.distanceBoard.position.set(0, 0.35, -1.5); // A bit above center, ~1.5m ahead
      state.scene.add(state.distanceBoard);
      
      // initial text
      state.distanceBoard.userData.draw('—');


      window.addEventListener('resize', () => {
        state.renderer.setSize(innerWidth, innerHeight);
      });

      const btn = ARButton.createButton(state.renderer, { requiredFeatures:['hit-test'] });
      document.body.appendChild(btn);

      state.renderer.setAnimationLoop(onXRFrame);
    }

    function onXRFrame(t, frame){
      if (!state.currentLLA || state.routeLLA.length === 0){
        state.renderer.render(state.scene, state.camera);
        return;
      }
      
      // Pick next target waypoint
      const target = state.routeLLA[Math.min(state.nextIdx, state.routeLLA.length-1)];
      const enu = ll2enu(target.lat, target.lon, state.currentLLA.lat, state.currentLLA.lon);

      // Rotate arrow to face target relative to camera
      const targetVec = new THREE.Vector3(enu.x, 0, enu.z).applyMatrix4(state.camera.matrixWorldInverse);
      
      // This line is corrected to ensure the chevron strip points along the direction of travel
      const yaw = Math.atan2(targetVec.x, targetVec.z); 

      state.guides.rotation.set(0, 0, yaw);


      // Advance when close
      const dist = Math.hypot(enu.x, enu.z);
      
      // Update HUD status text
      ui.status.textContent = `Next Waypoint: ${dist.toFixed(1)} m | Total Route: ${state.nextIdx+1}/${state.routeLLA.length}`;
      
      // Update total remaining distance (to destination, not just next waypoint)
      const remainingM = remainingDistanceMeters(state.currentLLA, state.routeLLA, state.nextIdx);

      // pretty print the distance
      let label;
      if (remainingM >= 1000) {
        label = `${(remainingM/1000).toFixed(2)} km`;
      } else {
        label = `${Math.max(0, Math.round(remainingM))} m`;
      }
      state.distanceBoard.userData.draw(label);

      // keep the board facing the camera (billboard)
      state.distanceBoard.quaternion.copy(state.camera.quaternion);
      // keep it ~1.5m in front of camera
      state.distanceBoard.position.set(0, 0.35, -1.5);

      if (dist < 5 && state.nextIdx < state.routeLLA.length-1) state.nextIdx++;

      state.renderer.render(state.scene, state.camera);
    }

    /* =========================
       GEOLOCATION + MAP FALLBACK
       ========================= */
    function startGeolocation(){
      if (!navigator.geolocation){ ui.status.textContent = 'Geolocation unavailable'; return; }
      state.watchId = navigator.geolocation.watchPosition(p => {
        const { latitude:lat, longitude:lon } = p.coords;
        state.currentLLA = { lat, lon };
        if (!state.originLLA) state.originLLA = { lat, lon };
        // update map marker when in fallback
        if (state.map){
          const center = [lon, lat];
          state.map.easeTo({ center, duration: 500 });
        }
      }, err => {
        ui.status.textContent = 'Location error: ' + err.message;
      }, { enableHighAccuracy:true, maximumAge: 1000, timeout: 8000 });
    }

    async function ensureMapFallback(){
      if (state.hasXR) return; // only if no WebXR
      ui.status.textContent = 'AR not supported here — showing map fallback';
      ui.mapEl.style.display = 'block';

      if (MAPBOX_TOKEN === 'YOUR_MAPBOX_ACCESS_TOKEN'){
          ui.status.textContent = 'Mapbox Token Missing! Fallback disabled.';
          return;
      }

      // lazy‑load Mapbox GL JS only if needed
      await import('https://api.mapbox.com/mapbox-gl-js/v3.2.0/mapbox-gl.js');
      // @ts-ignore global injected
      mapboxgl.accessToken = MAPBOX_TOKEN;
      state.map = new mapboxgl.Map({
        container: ui.mapEl,
        style: 'mapbox://styles/mapbox/streets-v12',
        center: [0,0], zoom: 16
      });
      state.map.addControl(new mapboxgl.NavigationControl());

      state.map.on('load', () => {
        if (!state.currentLLA) return;
        state.map.jumpTo({ center: [state.currentLLA.lon, state.currentLLA.lat] });
      });
    }

    /* =========================
       ROUTE HANDLERS
       ========================= */
    async function setRouteTo(dest){
      if (!state.currentLLA){ ui.status.textContent = 'Waiting for GPS fix…'; return; }
      try{
        ui.status.textContent = 'Fetching route…';
        state.routeLLA = await fetchRoute(state.currentLLA, dest);
        state.nextIdx = 0;
        ui.status.textContent = `Route ready: ${state.routeLLA.length} waypoints.`;
        
        // draw on fallback map
        if (state.map){
          const coords = state.routeLLA.map(p => [p.lon, p.lat]);
          const line = { type:'Feature', geometry:{ type:'LineString', coordinates: coords } };
          if (!state.map.getSource('route')){
            state.map.addSource('route', { type:'geojson', data: line });
            state.map.addLayer({ id:'routeLine', type:'line', source:'route', paint:{ 'line-width':5, 'line-color':'#34d399' } });
          } else {
            // @ts-ignore
            state.map.getSource('route').setData(line);
          }
          // Fit map to the route bounds
          const bounds = coords.reduce((b, c) => {
            // Check if bounds is initialized (first iteration)
            if (!b) return new mapboxgl.LngLatBounds(c, c);
            return b.extend(c);
          }, null);
          if (bounds) state.map.fitBounds(bounds, { padding: 32, duration: 800 });
        }
      }catch(e){ 
        ui.status.textContent = 'Routing error: ' + e.message; 
        console.error('Routing Error:', e);
      }
    }

    /* =========================
       UI WIRING
       ========================= */
    ui.btnRoute.addEventListener('click', () => {
      const lat = parseFloat(ui.destLat.value); 
      const lon = parseFloat(ui.destLon.value);
      if (Number.isFinite(lat) && Number.isFinite(lon)) setRouteTo({ lat, lon });
      else ui.status.textContent = 'Enter valid destination lat/lon';
    });

    /* =========================
       BOOT
       ========================= */
    startGeolocation();
    if (state.hasXR) { 
      initThree(); 
      ui.status.textContent = 'Tap “Enter AR” then pick a destination.'; 
    }
    // ensureMapFallback is awaited to load Mapbox if needed
    await ensureMapFallback();

    // Helpful defaults for quick test (San Francisco block demo)
    ui.destLat.value = '37.7754';
    ui.destLon.value = '-122.4180';
  </script>
</body>
</html>
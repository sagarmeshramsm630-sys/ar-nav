<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Web AR Navigation (Standards‑Only)</title>
  <!-- Mapbox GL JS (fallback map + routing fetch) -->
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.2.0/mapbox-gl.css" rel="stylesheet" />
  <style>
    :root { color-scheme: light dark; }
    html, body { height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #hud { position: fixed; top: env(safe-area-inset-top, 12px); left: 12px; right: 12px; z-index: 10; display:flex; gap:8px; align-items:center; background: color-mix(in oklab, Canvas 85%, transparent); backdrop-filter: blur(8px); border: 1px solid color-mix(in oklab, CanvasText 20%, transparent); border-radius: 14px; padding: 10px 12px; box-shadow: 0 4px 16px rgba(0,0,0,.1); }
    #status { font-weight: 600; font-size: 14px; }
    #controls { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    #controls input { width: 9rem; padding:.5rem .6rem; border-radius: 10px; border:1px solid color-mix(in oklab, CanvasText 25%, transparent); background: color-mix(in oklab, Canvas 90%, transparent); }
    #controls button { padding:.55rem .8rem; border-radius: 10px; border:1px solid color-mix(in oklab, CanvasText 25%, transparent); background: color-mix(in oklab, AccentColor 20%, Canvas 85%); font-weight:600; }
    #map { position: absolute; inset:0; display:none; }
    #permit { position: fixed; bottom: env(safe-area-inset-bottom, 12px); left: 12px; right: 12px; z-index: 10; text-align:center; font-size: 12px; opacity:.8; }
    /* three.js canvas fills page beneath HUD */
    canvas { display:block; width:100%; height:100%; }
  </style>
</head>
<body>
  <div id="hud">
    <div id="status">Initializing…</div>
    <div id="controls">
      <label style="font-size:12px; opacity:.7">Dest lat</label><input id="destLat" type="number" step="any" placeholder="e.g. 37.7754" />
      <label style="font-size:12px; opacity:.7">Dest lon</label><input id="destLon" type="number" step="any" placeholder="e.g. -122.4180" />
      <button id="btnRoute" title="Fetch route">Get route</button>
    </div>
  </div>
  <div id="map"></div>
  <div id="permit">Use outdoors. Requires motion+location permissions and HTTPS. If AR isn’t available, a live 2D map fallback will appear.</div>

  <!-- three.js + WebXR (module form) -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { ARButton } from 'https://unpkg.com/three@0.160.0/examples/jsm/webxr/ARButton.js';

    /* =========================
       CONFIG — fill in your Mapbox token
       ========================= */
    const MAPBOX_TOKEN = 'YOUR_MAPBOX_ACCESS_TOKEN'; // TODO: replace

    /* =========================
       STATE
       ========================= */
    const state = {
      hasXR: 'xr' in navigator,
      renderer: null, scene: null, camera: null,
      arrow: null, arrowLabel: null,
      originLLA: null, currentLLA: null,
      routeLLA: [], // {lat, lon}
      nextIdx: 0,
      map: null, mapLine: null,
      watchId: null,
    };

    const ui = {
      status: document.getElementById('status'),
      mapEl: document.getElementById('map'),
      destLat: document.getElementById('destLat'),
      destLon: document.getElementById('destLon'),
      btnRoute: document.getElementById('btnRoute'),
    };

    /* =========================
       GEO + MATH HELPERS
       ========================= */
    const R = 6378137; // WGS84 radius in meters
    function ll2enu(lat, lon, lat0, lon0){
      const dLat = (lat - lat0) * Math.PI/180;
      const dLon = (lon - lon0) * Math.PI/180;
      const x = R * dLon * Math.cos(((lat+lat0)*0.5) * Math.PI/180); // East
      const z = -R * dLat; // North -> -Z forward in Three
      return { x, z };
    }
    function haversine(a, b){
      const dLat = (b.lat-a.lat)*Math.PI/180;
      const dLon = (b.lon-a.lon)*Math.PI/180;
      const la1 = a.lat*Math.PI/180, la2 = b.lat*Math.PI/180;
      const h = Math.sin(dLat/2)**2 + Math.cos(la1)*Math.cos(la2)*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.min(1, Math.sqrt(h)));
    }

    /* =========================
       MAPBOX ROUTING (GeoJSON geometry)
       ========================= */
    // ✅ Free routing using OpenRouteService (no card needed)
// ✅ OpenRouteService via GET (no headers) — simplest & phone-friendly
const ORS_API_KEY = 'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6ImE0MzE1ZTY1YmIyZjQzNmJhMzU1NjEzMWRkOGE2YTI1IiwiaCI6Im11cm11cjY0In0=';

async function fetchRoute(origin, dest){
  const params = new URLSearchParams({
    api_key: ORS_API_KEY,
    start: `${origin.lon},${origin.lat}`, // NOTE: lon,lat order
    end:   `${dest.lon},${dest.lat}`
  });
  const url = `https://api.openrouteservice.org/v2/directions/foot-walking?${params.toString()}`;

  const res = await fetch(url, { mode: 'cors' });
  if (!res.ok) {
    // Show a readable error
    const txt = await res.text().catch(()=> '');
    throw new Error(`ORS ${res.status}: ${txt.slice(0,160)}`);
  }
  const json = await res.json();
  const feat = json.features?.[0];
  if (!feat) throw new Error('No route returned');
  return feat.geometry.coordinates.map(([lon, lat]) => ({ lat, lon }));
}


    /* =========================
       WEBXR / THREE SETUP
       ========================= */
    function initThree(){
      state.renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
      state.renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      state.renderer.setSize(innerWidth, innerHeight);
      state.renderer.xr.enabled = true;
      document.body.appendChild(state.renderer.domElement);

      state.scene = new THREE.Scene();
      state.camera = new THREE.PerspectiveCamera();

      const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
      state.scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(1,2,1); state.scene.add(dir);

      // Arrow: cone + stem
      const group = new THREE.Group();
      const cone = new THREE.Mesh(
        new THREE.ConeGeometry(0.18, 0.42, 24),
        new THREE.MeshStandardMaterial({ metalness: 0.1, roughness: 0.6 })
      );
      cone.rotation.x = -Math.PI/2;
      cone.position.z = -0.2;
      const stem = new THREE.Mesh(
        new THREE.CylinderGeometry(0.04, 0.04, 0.25, 20),
        new THREE.MeshStandardMaterial({ metalness: 0.1, roughness: 0.8 })
      );
      stem.rotation.x = -Math.PI/2;
      stem.position.z = 0.05;
      group.add(cone, stem);
      group.position.set(0, -0.2, -2);
      state.scene.add(group);
      state.arrow = group;

      window.addEventListener('resize', () => {
        state.renderer.setSize(innerWidth, innerHeight);
      });

      const btn = ARButton.createButton(state.renderer, { requiredFeatures:['hit-test'] });
      document.body.appendChild(btn);

      state.renderer.setAnimationLoop(onXRFrame);
    }

    function onXRFrame(t, frame){
      if (!state.currentLLA || state.routeLLA.length === 0){
        state.renderer.render(state.scene, state.camera);
        return;
      }
      // pick next target
      const target = state.routeLLA[Math.min(state.nextIdx, state.routeLLA.length-1)];
      const enu = ll2enu(target.lat, target.lon, state.currentLLA.lat, state.currentLLA.lon);

      // rotate arrow to face target relative to camera
      const targetVec = new THREE.Vector3(enu.x, 0, enu.z).applyMatrix4(state.camera.matrixWorldInverse);
      const yaw = Math.atan2(targetVec.x, -targetVec.z); // right-handed
      state.arrow.rotation.set(-Math.PI/2, 0, yaw);

      // advance when close
      const dist = Math.hypot(enu.x, enu.z);
      ui.status.textContent = `Next: ${dist.toFixed(1)} m | waypoint ${state.nextIdx+1}/${state.routeLLA.length}`;
      if (dist < 5 && state.nextIdx < state.routeLLA.length-1) state.nextIdx++;

      state.renderer.render(state.scene, state.camera);
    }

    /* =========================
       GEOLOCATION + MAP FALLBACK
       ========================= */
    function startGeolocation(){
      if (!navigator.geolocation){ ui.status.textContent = 'Geolocation unavailable'; return; }
      state.watchId = navigator.geolocation.watchPosition(p => {
        const { latitude:lat, longitude:lon } = p.coords;
        state.currentLLA = { lat, lon };
        if (!state.originLLA) state.originLLA = { lat, lon };
        // update map marker when in fallback
        if (state.map){
          const center = [lon, lat];
          state.map.easeTo({ center, duration: 500 });
        }
      }, err => {
        ui.status.textContent = 'Location error: ' + err.message;
      }, { enableHighAccuracy:true, maximumAge: 1000, timeout: 8000 });
    }

    async function ensureMapFallback(){
      if (state.hasXR) return; // only if no WebXR
      ui.status.textContent = 'AR not supported here — showing map fallback';
      ui.mapEl.style.display = 'block';

      // lazy‑load Mapbox GL JS only if needed
      await import('https://api.mapbox.com/mapbox-gl-js/v3.2.0/mapbox-gl.js');
      // @ts-ignore global injected
      mapboxgl.accessToken = MAPBOX_TOKEN;
      state.map = new mapboxgl.Map({
        container: ui.mapEl,
        style: 'mapbox://styles/mapbox/streets-v12',
        center: [0,0], zoom: 16
      });
      state.map.addControl(new mapboxgl.NavigationControl());

      state.map.on('load', () => {
        if (!state.currentLLA) return;
        state.map.jumpTo({ center: [state.currentLLA.lon, state.currentLLA.lat] });
      });
    }

    /* =========================
       ROUTE HANDLERS
       ========================= */
    async function setRouteTo(dest){
      if (!state.currentLLA){ ui.status.textContent = 'Waiting for GPS fix…'; return; }
      try{
        ui.status.textContent = 'Fetching route…';
        state.routeLLA = await fetchRoute(state.currentLLA, dest);
        state.nextIdx = 0;
        ui.status.textContent = `Route ready: ${state.routeLLA.length} points.`;
        // draw on fallback map
        if (state.map){
          const coords = state.routeLLA.map(p => [p.lon, p.lat]);
          const line = { type:'Feature', geometry:{ type:'LineString', coordinates: coords } };
          if (!state.map.getSource('route')){
            state.map.addSource('route', { type:'geojson', data: line });
            state.map.addLayer({ id:'routeLine', type:'line', source:'route', paint:{ 'line-width':5, 'line-color':'#3b82f6' } });
          } else {
            // @ts-ignore
            state.map.getSource('route').setData(line);
          }
          const bounds = coords.reduce((b, c) => b.extend(c), new mapboxgl.LngLatBounds(coords[0], coords[0]));
          state.map.fitBounds(bounds, { padding: 32, duration: 800 });
        }
      }catch(e){ ui.status.textContent = 'Routing error: ' + e.message; }
    }

    /* =========================
       UI WIRING
       ========================= */
    ui.btnRoute.addEventListener('click', () => {
      const lat = parseFloat(ui.destLat.value); const lon = parseFloat(ui.destLon.value);
      if (Number.isFinite(lat) && Number.isFinite(lon)) setRouteTo({ lat, lon });
      else ui.status.textContent = 'Enter valid destination lat/lon';
    });

    /* =========================
       BOOT
       ========================= */
    startGeolocation();
    if (state.hasXR) { initThree(); ui.status.textContent = 'Tap “Enter AR” then pick a destination.'; }
    await ensureMapFallback();

    // Helpful defaults for quick test (San Francisco block demo)
    ui.destLat.value = '37.7754';
    ui.destLon.value = '-122.4180';
  </script>
</body>
</html>

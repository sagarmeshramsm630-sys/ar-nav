<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAR Dynamic GPS Navigation</title>
    <!-- Tailwind CSS for modern, aesthetic UI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- A-Frame and AR.js Libraries for WebAR -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <!-- Using AR.js for markerless, Web-based AR tracking -->
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.1/aframe/build/aframe-ar-nft.js"></script>
    
    <style>
        /* Custom CSS to ensure the scene takes full viewport and typography */
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #000; }
        
        /* The AR scene must be full screen */
        #ar-scene {
            width: 100vw;
            height: 100vh;
        }

        /* UI Overlay for controls and information */
        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 1rem;
            box-sizing: border-box;
            pointer-events: none; /* Allows user to interact with the AR scene below */
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Top control bar for "Clear Navigation" */
        #top-bar {
            width: 100%;
            display: flex;
            justify-content: flex-end;
            margin-bottom: 1rem;
        }

        /* Info panel for displaying distance and status */
        #info-panel {
            background-color: rgba(0, 0, 0, 0.6);
            color: #00FFFF;
            padding: 0.5rem 1rem;
            border-radius: 0.75rem;
            font-size: 1.1rem;
            font-weight: 700;
            box-shadow: 0 0 15px #00FFFF80; /* Glowing effect */
            pointer-events: auto; 
            text-align: center;
        }

        .ar-button {
            pointer-events: auto; /* Re-enable pointer events for the button */
            background-color: rgba(34, 197, 94, 0.8); /* Semi-transparent Green */
            color: white;
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            transition: background-color 0.3s, transform 0.1s;
        }

        .ar-button:hover {
            background-color: rgba(5, 150, 105, 0.9);
        }

        .ar-button:active {
            transform: scale(0.98);
        }
    </style>
</head>
<body>

    <!--
        A-FRAME COMPONENT 1: FLOW PATH ANIMATION
        This controls the illusion of movement by continuously cycling the arrows.
    -->
    <script>
        AFRAME.registerComponent('flow-path', {
            schema: {
                speed: {type: 'number', default: 2.0}, // Faster flow for realism
                resetDistance: {type: 'number', default: 20}, // Longer path
                count: {type: 'number', default: 20} // More arrows
            },
            init: function () {
                this.arrows = [];
                // Initialize the arrow array
                for (let i = 0; i < this.data.count; i++) {
                    const arrow = this.el.querySelector(`#arrow-${i}`);
                    if (arrow) {
                        this.arrows.push(arrow);
                    }
                }
                this.active = true;
            },
            
            tick: function (time, deltaTime) {
                if (!this.active || !deltaTime) return;
                
                const deltaSeconds = deltaTime / 1000;
                // Speed is now in A-Frame units per second (e.g., meters)
                const distanceToMove = this.data.speed * deltaSeconds;
                
                // Move and check reset condition for each arrow
                this.arrows.forEach(arrow => {
                    const pos = arrow.object3D.position;
                    
                    // Move the arrow backward along the local Z-axis
                    pos.z -= distanceToMove;

                    // If the arrow has moved too far back, snap it to the front
                    if (pos.z < 0) {
                        // Reset to the position equivalent to the end of the path
                        pos.z += this.data.resetDistance; 
                    }
                });
            },

            stopFlow: function() { this.active = false; },
            startFlow: function() { this.active = true; }
        });

        // --- CORE NAVIGATION LOGIC ---

        // Hardcoded Destination: Central Park South, New York (Simulating a target point)
        const DEST_LAT = 40.7656; 
        const DEST_LON = -73.9744; 
        const INFO_PANEL = document.getElementById('info-panel');
        const PATH_ENTITY = document.getElementById('navigation-path');

        /**
         * Calculates the initial bearing (in degrees) between two GPS points.
         * Used to determine the target rotation for the AR path.
         */
        function calculateBearing(lat1, lon1, lat2, lon2) {
            const R_lat1 = lat1 * Math.PI / 180;
            const R_lat2 = lat2 * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;

            const y = Math.sin(dLon) * Math.cos(R_lat2);
            const x = Math.cos(R_lat1) * Math.sin(R_lat2) - 
                      Math.sin(R_lat1) * Math.cos(R_lat2) * Math.cos(dLon);
            
            let bearing = Math.atan2(y, x) * 180 / Math.PI;

            // Normalize bearing to 0-360 degrees
            return (bearing + 360) % 360; 
        }

        /**
         * Calculates the distance (in meters) between two GPS points using the Haversine formula.
         */
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // Earth's radius in meters
            const phi1 = lat1 * Math.PI / 180;
            const phi2 = lat2 * Math.PI / 180;
            const delta_phi = (lat2 - lat1) * Math.PI / 180;
            const delta_lambda = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(delta_phi / 2) * Math.sin(delta_phi / 2) +
                      Math.cos(phi1) * Math.cos(phi2) *
                      Math.sin(delta_lambda / 2) * Math.sin(delta_lambda / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c; // Distance in meters
        }

        // --- A-FRAME COMPONENT 2: DYNAMIC TARGET ROTATION ---
        
        AFRAME.registerComponent('dynamic-target-rotation', {
            init: function () {
                this.currentHeading = null;
                this.targetBearing = null;
                this.currentLat = null;
                this.currentLon = null;
                this.el.setAttribute('visible', false); // Hide path until GPS is ready
                
                this.compassHandler = this.updateCompass.bind(this);
                this.geoSuccessHandler = this.updateGeoPosition.bind(this);
                
                this.startTracking();
            },

            startTracking: function() {
                // 1. Start Geolocation Watcher
                if (navigator.geolocation) {
                    this.geoWatcher = navigator.geolocation.watchPosition(
                        this.geoSuccessHandler, 
                        (error) => { console.error('Geolocation Error:', error); INFO_PANEL.textContent = 'GPS Error: Check Location Settings.'; },
                        { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
                    );
                } else {
                    INFO_PANEL.textContent = 'Geolocation not supported.';
                }

                // 2. Request Device Orientation (Compass) Permission
                if (window.DeviceOrientationEvent) {
                    // Check if permission is needed (iOS 13+)
                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        document.body.addEventListener('click', () => { // Triggered by first user interaction
                            DeviceOrientationEvent.requestPermission()
                                .then(permissionState => {
                                    if (permissionState === 'granted') {
                                        window.addEventListener('deviceorientationabsolute', this.compassHandler, true);
                                        INFO_PANEL.textContent = 'Compass Active... Waiting for GPS...';
                                    } else {
                                        INFO_PANEL.textContent = 'Compass Permission Denied.';
                                    }
                                })
                                .catch(console.error);
                        }, { once: true });
                        INFO_PANEL.textContent = 'Tap screen to enable Compass.';
                    } else {
                        // For Android and older iOS
                        window.addEventListener('deviceorientationabsolute', this.compassHandler, true);
                        INFO_PANEL.textContent = 'Waiting for GPS...';
                    }
                } else {
                    INFO_PANEL.textContent = 'Device Orientation not supported.';
                }
            },

            updateGeoPosition: function (position) {
                this.currentLat = position.coords.latitude;
                this.currentLon = position.coords.longitude;
                
                // Calculate bearing to destination
                this.targetBearing = calculateBearing(
                    this.currentLat, this.currentLon, 
                    DEST_LAT, DEST_LON
                );
                
                // Calculate distance
                const distanceMeters = calculateDistance(
                    this.currentLat, this.currentLon, 
                    DEST_LAT, DEST_LON
                );
                
                // Update UI and visibility
                this.el.setAttribute('visible', true);
                INFO_PANEL.textContent = `Destination: ${distanceMeters.toFixed(0)}m away.`;
            },
            
            updateCompass: function (event) {
                // 'alpha' is the rotation around the Z-axis, or the compass heading (0 = North)
                if (event.alpha !== null) {
                    // Current heading relative to North
                    this.currentHeading = event.alpha;
                }
            },

            tick: function () {
                if (this.currentHeading === null || this.targetBearing === null) return;
                
                // --- THE CRITICAL STEP: ROTATE THE PATH ---
                // 1. Calculate the difference between the destination's bearing and the device's current heading.
                // 2. This difference is the rotation needed for the AR path (this.el).
                let rotationAngle = this.targetBearing - this.currentHeading;
                
                // Normalize rotation angle to keep it between -180 and 180 for smoother A-Frame rotation
                if (rotationAngle > 180) rotationAngle -= 360;
                if (rotationAngle < -180) rotationAngle += 360;

                // Apply rotation to the AR path container (Y-axis rotation for horizontal turning)
                // We rotate the entire path entity around the Y-axis.
                this.el.setAttribute('rotation', `0 ${rotationAngle} 0`);
            },

            remove: function () {
                // Cleanup on component removal
                window.removeEventListener('deviceorientationabsolute', this.compassHandler, true);
                if (navigator.geolocation && this.geoWatcher) {
                    navigator.geolocation.clearWatch(this.geoWatcher);
                }
            }
        });

        // Function linked to the "Clear Navigation" button
        function clearNavigation() {
            const pathEntity = document.querySelector('#navigation-path');
            const clearButton = document.querySelector('#clear-nav-button');
            const flowComponent = pathEntity.components['flow-path'];
            const rotationComponent = pathEntity.components['dynamic-target-rotation'];

            if (pathEntity && flowComponent && rotationComponent) {
                // Stop AR movement and rotation updates
                flowComponent.stopFlow();
                rotationComponent.remove();
                
                // Update UI
                pathEntity.setAttribute('visible', false);
                clearButton.textContent = 'Navigation Cleared';
                clearButton.disabled = true;
                INFO_PANEL.textContent = 'Navigation Halted.';
            }
        }
    </script>


    <!-- UI Overlay (Tailwind CSS classes for aesthetics) -->
    <div id="ui-overlay">
        <div id="top-bar">
            <button id="clear-nav-button" class="ar-button bg-cyan-600 hover:bg-cyan-700 shadow-xl shadow-cyan-500/50" onclick="clearNavigation()">
                Clear Navigation
            </button>
        </div>
        <div id="info-panel" class="mt-4">
            Initializing AR and Compass...
        </div>
    </div>

    <!-- A-Frame Scene Setup -->
    <a-scene 
        id="ar-scene"
        vr-mode-ui="enabled: false"
        renderer="logarithmicDepthBuffer: true; colorManagement: true"
        arjs='sourceType: webcam; trackingMethod: best; debugUIEnabled: false;'>

        <!--
            The Path Container - NOW WITH REAL-TIME ROTATION
            This entity is positioned at the user's location (0, 0, 0) and is dynamically
            rotated by the 'dynamic-target-rotation' component to point to the destination.
        -->
        <a-entity id="navigation-path" 
                  flow-path="count: 20; speed: 2.0; resetDistance: 20"
                  dynamic-target-rotation>

            <!--
                Arrow Geometry Definition - Highly Emissive/Glowing Cyan
            -->
            <a-mixin id="arrow-shape"
                     geometry="primitive: circle; segments: 3; radius: 0.2; buffer: true"
                     rotation="90 0 0"
                     material="color: #00FFFF; opacity: 0.85; metalness: 0.5; roughness: 0.5; emissive: #00FFFF; emissiveIntensity: 2.0; shader: standard"
                     ></a-mixin>

            <!--
                Path Generation (20 arrows spaced 1 unit apart)
                The flow-path component makes these appear to move continuously forward.
            -->
            <a-entity mixin="arrow-shape" id="arrow-0" position="0 0.05 19"></a-entity>
            <a-entity mixin="arrow-shape" id="arrow-1" position="0 0.05 18"></a-entity>
            <a-entity mixin="arrow-shape" id="arrow-2" position="0 0.05 17"></a-entity>
            <a-entity mixin="arrow-shape" id="arrow-3" position="0 0.05 16"></a-entity>
            <a-entity mixin="arrow-shape" id="arrow-4" position="0 0.05 15"></a-entity>
            <a-entity mixin="arrow-shape" id="arrow-5" position="0 0.05 14"></a-entity>
            <a-entity mixin="arrow-shape" id="arrow-6" position="0 0.05 13"></a-entity>
            <a-entity mixin="arrow-shape" id="arrow-7" position="0 0.05 12"></a-entity>
            <a-entity mixin="arrow-shape" id="arrow-8" position="0 0.05 11"></a-entity>
            <a-entity mixin="arrow-shape" id="arrow-9" position="0 0.05 10"></a-entity>
            <a-entity mixin="arrow-shape" id="arrow-10" position="0 0.05 9"></a-entity>
            <a-entity mixin="arrow-shape" id="arrow-11" position="0 0.05 8"></a-entity>
            <a-entity mixin="arrow-shape" id="arrow-12" position="0 0.05 7"></a-entity>
            <a-entity mixin="arrow-shape" id="arrow-13" position="0 0.05 6"></a-entity>
            <a-entity mixin="arrow-shape" id="arrow-14" position="0 0.05 5"></a-entity>
            <a-entity mixin="arrow-shape" id="arrow-15" position="0 0.05 4"></a-entity>
            <a-entity mixin="arrow-shape" id="arrow-16" position="0 0.05 3"></a-entity>
            <a-entity mixin="arrow-shape" id="arrow-17" position="0 0.05 2"></a-entity>
            <a-entity mixin="arrow-shape" id="arrow-18" position="0 0.05 1"></a-entity>
            <a-entity mixin="arrow-shape" id="arrow-19" position="0 0.05 0"></a-entity>

            <!-- A line spine to add depth to the path -->
            <a-entity line="start: 0 0.01 0; end: 0 0.01 20; color: #00FFFF; opacity: 0.3; linewidth: 5"></a-entity>
        </a-entity>

        <!-- The camera element. AR.js handles all camera-related tracking automatically. -->
        <a-camera></a-camera>

    </a-scene>

</body>
</html>